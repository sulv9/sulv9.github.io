[
  
  {
    "title": "测试博客",
    "url": "/posts/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/",
    "categories": "",
    "tags": "",
    "date": "2021-12-12 00:00:00 +0800",
    





    "snippet": ""
  },
  
  {
    "title": "Git指南-实战篇",
    "url": "/posts/Git%E6%8C%87%E5%8D%97-%E5%AE%9E%E6%88%98%E7%AF%87/",
    "categories": "Git",
    "tags": "git",
    "date": "2021-09-18 14:14:43 +0800",
    





    "snippet": "准备阶段创建Github仓库首先，我们打开Github，新建一个仓库Test，用来学习团队Git合作开发：创建本地仓库然后在本地电脑上新建一个同名的文件夹Test📂，这里因为是示例项目，全程只用一个README.md文件，所以我们只用在Test文件夹里创建一个README.md文件：现在我们先在README.md文件写入我们第一次要提交的内容：其中[main]表示的是当前的分支名称，其后的内容表示第一次修改的内容信息。提交本地仓库至远程仓库接着我们回到Test文件夹里，单击鼠标右键，选择Git Bash Here，进入Git命令行界面，按照创建Github仓库时给出的提示（上面第一张图中的内容）依次输入命令初始化仓库：接下来返回Github仓库刷新一下界面就可以看到我们刚刚推上去的README.md文件了。让我们回到电脑本地的README.md文件里，再提交一次新的commit：注意，这里作为示例，commit提交说明写得不太规范，commit提交信息规范请参考另一篇Git指南文章。那么此时我们的分支状态如下，其中AB分别表示我们在Main分支上的两次提交：这个Main分支作为项目开发的主分支（这里是示例项目，正常的项目一般使用develop分支作为开发分支，main分支作为线上发布版本的分支），此时假如我们需要为项目开发一个新的功能，先从Main分支上切出一个新的分支feature，基于此分支进行开发。首先我们现在Git Bash内输入下面这行代码，表示新建并切换到feature分支上：git checkout -b feature此时我们已经创建了一个分支feature，并切换到该分支上进行工作了：接下来我们分别在此分支上进行三次commits：并使用git log --oneline查看log记录：此时我们的分支状态如下，其中CDE分别表示在Feature分支上的三次提交：多人协作开发这里我们先模仿此时有另外一位同事向远端提交了代码，首先checkout回main分支，并新加一次commit，push到远端仓库：此时的分支状态如下，F表示我们模仿的同事的提交：那么这时如果已经开发完新功能的你想要push代码到远程仓库上去的话，有两种选择。Git Merge第一种选择是merge，即将feature分支与main分支内容合并，并产生一个新的提交记录，对应的步骤如下：  在feature分支输入git pull origin main拉去远程仓库main分支的最新代码，如果产生冲突则打开指定文件解决冲突。  解决完冲突后分别git add、git commit  然后输入git push --set-upstream feature，表示提交当前分支内容到远程一个名为feature的分支上，如果没有则自动创建该远程分支。  此时打开Github仓库，你会发现多出了一个新的分支，进入该分支根据提示提交PR，选择Create a merge commit即可合并feature代码到main分支上，别忘了合并后选择Delete Branch删除远程仓库的该分支哦。OK，这就是第一种合并的方法，也是最简单、最普遍的提交方法，你不需要关心无法提交、代码内容覆盖等问题，但是，这种方法也有很大的问题暴露出来了：  在Github每次使用Create a merge commit时都会按照提交时间先后合并所有的commits记录，并在合并完成后创建一次新的commit提交，这样会导致commits历史提交记录繁杂冗余，一是不方便他人review代码，二是不方便之后如果代码出了问题需要回退版本，因为commits太多太乱，很难找到自己要回退的版本。所以这里我个人更加推荐第二种提交方式：git rebase。Git RebaseRebase翻译过来是变基的意思，而git rebase就是改变当前分支的基（这里我也描述不清楚）。📖理解举个现实中的例子，假如一名大叔年过三十仍未娶妻，于是他打算收养一名孩子，虽然收养来的孩子待遇和亲身孩子一样，但血脉却和大叔的不一样。但是git base这个黑魔法却可以让大叔收养来的这个孩子血脉也变得和大叔一样，也就是说rebase让这个收养来的孩子变成了大叔的亲生孩子。（这个例子举的或许有些离谱，但只是我个人的理解哈😅）那么上面提到的大叔就是在我们创建Feature分支前的Main分支，领养孩子的行为相当于新建一个分支，并将其命名为Feature，当然，这时新建的分支的base其实和Main还是一模一样的，所以没必要rebase，但是当我们模拟一名同事提交一个新的commit到Main上后，Main分支的base就变了，这里我们就需要用到黑魔法git rebase来把feature分支重新拼接到Main分支上，即将feature分支的base同步为最新的。其实在你push代码之前，还可以使用git rebase -i指令来完成对commits的一系列操作，所以这里我会先介绍其的使用。🎯实战1. push之前 - 对commits进行的骚操作🌠squash - 压缩多条提交记录在Git Merge中我们已经提到过直接Merge代码会导致commits冗余繁杂，那么其实我们可以使用git rebase -i来压缩合并多次commit记录：      首先切换回feature分支，这里我们以合并feature分支上的最后三次提交为例来介绍该指令。首先在命令行中输入下面的指令：    git rebase -i HEAD~3        这里我们在最后加了个参数HEAD~3，表示对最后三次提交记录进行操作。按下Enter，你会进入下图的界面：        别看上面一大串英文，其实有效代码只有前三行，剩下的都是注释说明，介绍git rebase -i指令的使用说明，这里我们即将要用到的s，squash &amp;lt;commit&amp;gt;表示压缩提交记录，它会自动压缩当前commit与上一条commit的提交，所以下面我们只需要将后两个pick指令改为s或者squash即可。        按下i键进入编辑模式，并修改后两行的pick为s，修改完后按下Esc键，并输入:wq（这属于vim编辑器的操作）：            第二步完成后按下Enter，会进入下面的界面：        在上图中的第一行和第二行之间新建一行，并在其中写下此次合并Commit的主要信息，剩下的几行是对压缩的每次提交的额外描述（别忘了点击i进入编辑模式哦）：        编辑完后按Esc，并输入:wq然后Enter表示保存并退出。    因为在这里我们可以对压缩的每个commit进行详细说明，所以不会产生别人看不到你的commit的情况，因此我个人更推荐这样的提交方式。        之后你会看到压缩成功的提示。输入git log --oneline查看历史记录，你会发现最后三次提交已经被压缩成了一次提交：        PR之后的效果如下图所示：      🌠reword - 修改提交信息r/reword：修改commit的信息，注意reword只会修改commit的提交说明信息，而不会修改本次commit的具体内容。注意，reword之后会修改commit的SHA值。🌠edit - 插入新的commit或者修改commit具体内容e/edit：它可以帮助你在过去的某个commit间插入新的commit或者修改某次commit的具体内容（注意这里要和reword区分开）。修改成edit操作后，git会先回退到edit指向的commit记录，之后你可以对当前版本的commit进行修改，修改完后使用git add .将文件添加到暂存区，此时你有两个选择，如果你不想新增一个commit，直接使用git commit --amend，然后再git rebase --continue；如果你想在当前commit之后再新增一条commit，直接使用git commit -m&quot;提交信息&quot;，然后再git rebase --continue来新增commit。注意：edit以及之后的commits的SHA值都会被修改。🌠fixup - 压缩提交但丢弃较晚的提交信息f/fixup：它类似于squash，但我们使用squash的时候会被要求添加压缩提交的具体信息，但是使用fixup时Git会自动以较早的提交信息作为此次压缩的info。举个例子，假如现在你想要对下面这两条提交进行fixup操作，那么首先使用git rebase -i HEAD~2进行编辑指令界面，然后修改第二行的pick为f，按下Enter后会直接提示你变基成功。之后我们查看log信息如下图所示，可以发现：第四次commit和第五次commit被压缩生成了一次新的commit，并新commit的提交信息和第四次的commit的信息一样，而且要注意的是，新生成的commit的SHA值也会重新生成。🌠exec - 执行shell语句e/exec：这个我很少用到，就在这里简单记录一下叭。就是在进入编辑指令界面后任意一行插入e+shell指令，在变基时会自动执行。例如e echo &quot;This is a echo...&quot;，Enter后就可以看到命令行里多出一句Executing: echo &quot;This is a echo......&quot;。🌠drop - 删除提交d/drop：这个使用起来比较简单，直接将pick指令换成d即可。但是需要注意的是建议只对最后一次的commit进行删除，如果你删除了前面的commit，那么git会从你删除的commit后最早的一次commit开始，重新合并解决冲突，直到最晚的commit为止。举个例子，假如现在这里有五次commit，你对第三次的commit执行了drop命令，那么此时git的HEAD会首先指向第二次的commit，接着它会依次与第四次commit、第五次commit合并，如果遇到冲突则解决冲突，对于每一次的合并操作，都会改变其SHA值并提醒你重新输入commit提交信息。所以如果你突然删除了中间的某个commit，但是(你要删除的commit)之后的commits都是基于该commit来完成的，这样就会为你的开发带来一定的麻烦。参考博客：【git 整理提交】git rebase -i 命令详解_the_power的博客-CSDN博客git rebase使用场景 - 看风景就 - 博客园 (cnblogs.com)彻底搞懂 Git-Rebase - Jartto’s blog2. push代码到Github      第一步：在提交你的代码之前，请先使用git pull origin main --rebase来拉取远程仓库中main分支的代码，--rebase表示在拉取代码后执行git rebase操作。👻注意，这里你需要分别对每个commit执行解决冲突操作，并在每次解决完冲突后可以选择修改此次解决冲突后commit的提交信息。所以为了避免麻烦，可以选择第一个步里的squash指令，先将几次commit合并后再提交。        第二步：使用git push提交你的代码到远程仓库        第三步：打开Github仓库页面，切换到feature分支上会有提示合并的消息，选择Open pull request：        按照提示一直点下去，最后选择Rebase and merge选项，并在合并完成之后删除该分支：            关于三种PR方式的不同我会在另一篇Git指南文章中讲到。  这样你就成功将代码安全的提交到Github远程仓库上去了。🚨注意rebase的实质Git Rebase虽然强大，但也有一些它的缺陷。其实在上面的内容中相信你也已经发现了，每个commit都有属于自己的专属hash值（相当于身份证），但是git rebase的操作会改变目标commit的hash值，因为它是通过将你现有的commits复制一份到新的commits上，并在新的commits上进行改进，之后将原来的commits再删除。  When you rebase stuff, you’re abandoning existing commits and creating new ones that are similar but different.  变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。  (摘自Pro Git 变基 (git-scm.com))rebase带来的风险举个栗子：这里有一个远程分支A，A上有两次提交B和C，现在你和同事张三一起把分支A拉取到本地进行开发。假如你对提交B或C进行了git rebase操作，并将其推送到了远程分支上，那么张三在完成开发后打算拉取远程最新代码时，就不得不重新整合他的代码，因为在张三那里，提交B和C的hash值和最初A仓库中的是一样的，而由于你的rebase操作改变了这两个提交的hash值，那么很尴尬的处境就在张三那里发生了，两个一模一样的提交同时出现在了他那里，这让张三感到很混乱且头大。再举个不恰当的例子方便理解，假如你的妻子生了一个孩子，你俩共同抚养其长大，结果突然有一天你发现这个孩子的血脉和你不一样，一问才知道，你的妻子使用了黑魔法git rebase让这个孩子的血脉变成别人的了，你说你气不气。👻  Do not rebase commits that exist outside your repository and that people may have based work on.  If you follow that guideline, you’ll be fine. If you don’t, people will hate you, and you’ll be scorned by friends and family.  如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。  如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。  (摘自Pro Git - 变基 (git-scm.com))即不要对已经推送到远程分支的commits进行变基操作。如何避免风险      第一种方法就是当你推送分支时使用git push --force-with-lease，如果远端有其他人推送了新的提交，那么你此次的提交会被自动拒绝。可以参考博客Git 更安全的强制推送，–force-with-lease_walterlv - 吕毅-CSDN博客    第二种方法就是在你每次提交前都要使用git pull --rebase操作，它会对拉取到的代码自动执行变基操作，即Pro Git中提到的用变基解决变基。如果你不想每次pull时都多写一遍--rebase的话，可以使用git config --global pull.rebase true语句更改pull的配置，每次pull时会自动rebase。  个人推荐做法：每当你打算基于某个分支进行开发时，首先基于它创建一个新的只属于你自己的分支，并在新的分支进行开发，开发完成后使用git pull origin main --rebase拉取远程仓库分支的代码，然后直接使用git push提交，最后在Github的PR里选择Rebase and merge进行合并操作。这也是上面关于Git Rebase实战的流程。Rebase vs. Merge有人认为项目仓库的每次提交历史都在记录实际发生过什么，不能对它们随意修改；也有人认为提交历史是项目过程中发生的事，需要反复修改才能得到较好的效果。实际上你应当视具体项目来选择用哪一种方式，抑或是两者结合着用，但无论如何，请始终记住一个原则：只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。参考文章：git - Why should we never use rebase with commits that have been pushed - Stack OverflowGit - 变基 (git-scm.com)Git - Rebasing (git-scm.com)"
  },
  
  {
    "title": "Git指南-基础篇",
    "url": "/posts/Git%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%E7%AF%87/",
    "categories": "Git",
    "tags": "git",
    "date": "2021-09-18 14:14:43 +0800",
    





    "snippet": "为什么要用Git？  方便多人远程协作开发  教学相长，在review别人代码的同时也能被别人发现自己代码里的问题，提升代码水平  可以让你放心大胆地开发，随时可以回退版本或者新建分支Git常用指令指南新建代码仓库      git init  初始化Git仓库        git clone [url]  克隆远程仓库代码到本地  Git config相关指令      git config [--global] user.name &quot;[name]&quot;        git config [--global] user.email &quot;[email address]&quot;  分别配置提交代码时用户的姓名和电子邮箱，其中如果加上--global表示全局配置，不加则表示仅作用于当前仓库。Git Branch相关指令      git branch  显示所有本地分支列表        git branch -r  显示所有远程分支列表        git branch -a  显示所有本地和远程分支列表        git branch -m [branch-name]  修改当前分支的名字        git branch [branch-name]  新建一个分支，且当前分支不会自动切换        git branch -d [branch-name]  删除指定的本地分支        git branch -dr [remote/branch]  删除指定的远程分支，远程仓库地址+’/’+远程分支名        git checkout [branch-name]  切换到指定分支        git checkout -b [branch-name]  创建并自动切换到指定分支  增加/删除与提交  git add .  添加当前目录下的所有文件到缓存区      git rm [file-name]  将文件从工作区中移除并重新放入暂存区    git mv [file-original] [file-renamed]  改名文件，并将其放入暂存区  git commit -m&quot;message&quot;  提交暂存区到仓库区  git commit -v  显示工作区文件所有的diff信息远程同步  git remote add [short-name] [url]  添加一个远程仓库，[short-name]为别名，[url]为远程仓库地址      git pull origin [branch-name] --rebase  拉取远程分支的最新代码，并执行变基操作。        git push [remote] [branch-name]  推送代码至远程仓库的指定分支上，[remote]为远程仓库地址，[branch-name]为远程仓库的分支名，这里需要远程仓库存在该分支才能执行成功。        git push -u origin [branch-name]  同样是推送当前分支代码到远程仓库的指定分支上，但-u指令指定了默认主机，以后可以直接使用git push进行推送，而且如果此时远程仓库不存在该分支会自动创建。    git push --set-upstream [remote] [name-of-your-branch-name]  推送当前分支到远程仓库的相应分支，[remote]表示远程仓库地址，第二参数是你的分支名，该指令会自动在远程仓库创建一个新的分支。  git push --force-with-lease  强行推送代码，但不会覆盖，操作安全。查看信息      git status  显示有变更的文件        git log --oneline  简洁查看当前版本的历史记录        git reflog  显示当前分支的操作记录        git diff  显示工作区与暂存区的差异  撤销      git reset --hard &amp;lt;hash&amp;gt;  重置暂存区与工作区代码到指定的某次提交        git stash  将工作区与暂存区的内容保存至堆栈中        git stash pop  将堆栈中保存的内容移至当前分支    git stash使用可以参考这个博客：git stash详解_stone_yw的博客-CSDN博客_git stash  Git tag相关指令展示标签  git tag  显示所有的标签  git show [tag-name]  查看标签的具体信息创建标签  git tag [tag-name]   创建一个轻量级标签  git tag -a [tag-name] -m &quot;message&quot;  创建一个完整的标签  git tag -a [tag-name] [commit-hash] -m &quot;message&quot;  为指定的commit打上标签远程推送  git push origin [tag-name]  推送单个标签至远程仓库（注意，正常push时不会自动提交标签）  git push origin --tags  推送全部标签至远程仓库删除标签  git tag -d [tag-name]  删除本地标签  git push [remote] :refs/tags/[tagname]  删除远程分支标签切换标签  git checkout [tag-name]  切换HEAD指向目标tag对应的commit  git checkout -b [new-branch-name] [tag-name]  从指定tag对应的commit切出一条新的分支Git tag vs branchSame标签和分支都是作用于一个commit的，它们都是用来方便帮助我们不用去记忆commit的hash值的。Different当你执行git tag时，相当于为当前最新的commit打上了标记，这个标记是刻在该commit上的，除非该commit被删除，否则标记不会被改变。但是git branch就不太一样，branch始终会记录你的最新提交，每当有新的commit提交时branch都会跟着变动。  The difference between tags and branches are that a branch always points to the top of a development line and will change when a new commit is pushed whereas a tag will not change. Thus tags are more useful to “tag” a specific version and the tag will then always stay on that version and usually not be changed.  标签和分支之间的区别在于，分支始终指向开发线的顶部，并且会在推送新提交时更改，而标签不会更改。因此，标签对于“标记”特定版本更有用，并且标签将始终保留在该版本上并且通常不会更改。  (摘自wikibooks-git)Practice假如项目上线发布了v1.0版本，然后你负责继续开发之后的版本。在你将v1.1版本的代码写完后打算开始v1.2版本的开发，但是当你把v1.2版本开发到一半时突然v1.1版本被发现有bug，并且此时v1.1版本需要上线而v1.2版本的新功能暂时不上线，那么你就可以先在当前代码处打上一个v1.2.1标签，然后checkout回v1.1标签版本修复bug，修复完成后推送至远端分支，并在切换回v1.2.1版本后拉取最新分支。有些人可能会问，你这么麻烦还不如直接新建v1.1和v1.2两个分支进行开发得了，但是一个项目的版本可能会非常多，例如v1.1.2-rc.3，v2.1.3-a.1等等非常多的版本，每个版本都新建一个分支来保存状态的话岂不是太多太乱了。其实tag就是commit的简易别名，正常情况下假如你要切换到某次commit的代码状态时需要它的hash值，但打上标签后你只需要使用标签名即可方便切换。参考文章：常用 Git 命令清单 - 阮一峰的网络日志 (ruanyifeng.com)Git - 打标签 (git-scm.com)Git/Advanced - Wikibooks, open books for an open worldGit开发规范指南Commit message格式格式：git commit -m &quot;[type]Write your messages here.&quot;其中[type]有下面几种类型：feat：新功能（feature）fix：修补bugoptimize：优化style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）Github开发规范  不能直接在main/develop分支上进行开发  在提交PR时尽量选择第三个选项Rebase and merge，提完PR后将自己的远程分支删除  每次更新一个小版本之后要记得打上tag"
  },
  
  {
    "title": "ARTS-1",
    "url": "/posts/ARTS-1/",
    "categories": "其他",
    "tags": "ARTS",
    "date": "2021-09-08 15:10:43 +0800",
    





    "snippet": "  前言：因为是第一次做ARTS，再加上刚开学要迎新，还有一些学业等等其他的一些事情，现在是2021年9月23日，距离新建这篇文章已经过去了十五天的时间，两周零一天，效率之低令人惊叹，划水之怠令人懊悔。但“悟已往之不谏，知来者之可追”，与其抱怨黑暗，不如提灯前行。现在是周四，周日还要补下周三的课，定个目标，这周结束前将Arouter的相关知识搞定（但博客可能要来不及写了）。                    补充一下：ARTS是什么？它是陈皓提出的一种学习方法，可以参考一下两篇文章：ARTS 是什么？ - 简书 (jianshu.com)和[左耳听风        ARTS 打卡召集令](https://time.geekbang.org/column/article/85839)。            Algotithm算法是第二周才做的，因为第一周迎新占了些时间，周末也有些摸鱼了😥然后就跟着力扣初级算法的小册先做了一道最简单的数组算法题，主要考点是双指针，🤧题目如下：  给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。  示例：  输入：nums = [1,1,2]输出：2, nums = [1,2]    作者：力扣 (LeetCode)链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/然后下面是我的题解，看到了评论中有双指针三个字才想起来的，一开始还打算开一个flag从0开始不断增大，如果遇到和自身不相等的数则flag++，最后发现这样只能得到数组中不重复数字的数量，却无法将这些重复的数字删除。int removeDuplicates(int* nums, int numsSize){    if (numsSize &amp;lt;= 0) return 0;    int front = 0;    for (int end = 1; end &amp;lt; numsSize; end++) {        if (nums[end] != nums[front]) {            front++;            nums[front] = nums[end];        }    }    return front + 1;}双指针法，名字虽然叫指针，但这道题里可以用下标数字代替，front表示未重复数字在数组中对于的下标，end就是始终走在front前面的下标，可以把它看成一个哨兵，如果发现了和front不同的数字，就会提醒front加一，并记录新的数字。整体思路挺简单的，没啥好说的。Review这里在写关于Git的博客的时候参考了许多博客，包括国内外的，已经在文章相应的各处添加了相应的博客链接。Tips首先是关于Github上提交PullRequest时的三个选项，如下图：  Create a merge commit(创建合并提交): 将所有新增的commit依次合并到主分支上，它会保留记录你在本地分支上所有的修改记录。示例图如下：  Squash and merge(压缩且合并): 将所有新增的commit压缩成一次提交记录合并到主分支上，通俗点讲就是将你的commits揉成一团丢到主分支上面去，别人无法查看你commit细节。在合并完成之后Github不会自动帮你删除当前分支，但是会有一条提示告诉你当前分支已经合并到主分支上，你可以将当前分支安全地删除了。  Rebase and merge(变基且合并): 具体请查看我的另一篇Git实战的文章。参考文章：Git三大特色之WorkFlow(工作流)_段浅浅的博客-CSDN博客_git 工作流Squashing Your Pull Requests - Cloud Fourgit - What is the difference between merge –squash and rebase? - Stack OverflowWhat’s the Difference Between the 3 Github Merge Methods? (rietta.com)            [Squash your commits      The GitHub Blog](https://github.blog/2016-04-01-squash-your-commits/)      git - What is the difference between merge –squash and rebase? - Stack Overflowgit - GitHub can’t rebase my feature branch: “This branch cannot be rebased due to conflicts” - Stack Overflow合并拉取请求 - GitHub DocsShare请查看我写的两篇关于Git的文章，一篇为Git指南基础篇，另一篇为Git指南实战篇。  结尾语：做了第一次的ARTS还是感觉有一点不太习惯，觉得不是很适合我，得再加以改造一下。  首先Algorithm是必要的，每周都要至少刷一道算法题。  然后第二项Review内容，是为了让我们多阅读国外大佬的博客，这个我觉得当我要去学习一个知识的时候肯定是需要查阅谷歌的，在写博客的时候也会参考一些国外的博客，这一部分没必要单独展示出来，可以先删除。  然后第三项Tips，是记录平时工作或者开发过程中需要注意的点，觉得还不错，可以保留。  第四项Share，写一篇博客我感觉真的需要花费很多时间😓，有些东西你用起来可能会了，但让你讲出来就有些麻烦，需要查阅大量资料，像有一些模棱两可的观点都不应该在博客中出现，所以这一块我觉得可以把时间延长到两周来写，因为真的不想随便写篇博客去敷衍一下。  除了上面这些，我觉得在开启新的一周的学习前需要先规划一下下一周的学习路线，这个路线不能定太高，实现不了，需要在每一周之前我们“实地考察”，去大致浏览一些下周要学习的知识点，不需要深入看，然后制定好StudyMap，这个我会写在Notion上，在每周总结的开始也会给出来。制定好具体的下周要学的内容后就完全可以按照map走就行，所以这点还是蛮重要的，就叫Preview吧。然后在学习过程中需要记下很多note，最后要将note整理成博客，即share内容。所以下周开始做的就是PATS了。"
  }
  
]

