<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Android模块化知识分享" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="1 Android模块化知识分享 未经允许，禁止转载 1.1 定义 1.1.1 模块化定义 Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.（摘自wiki百科） 模块化编程是一种软件设计技术，它强调将程序的功能分离为独立的、可互换的模块，使每个模块都包含执行所需功能的一个方面所必需的一切。" /><meta property="og:description" content="1 Android模块化知识分享 未经允许，禁止转载 1.1 定义 1.1.1 模块化定义 Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.（摘自wiki百科） 模块化编程是一种软件设计技术，它强调将程序的功能分离为独立的、可互换的模块，使每个模块都包含执行所需功能的一个方面所必需的一切。" /><link rel="canonical" href="https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/" /><meta property="og:url" content="https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/" /><meta property="og:site_name" content="Sulv’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-08T15:09:42+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Android模块化知识分享" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"1 Android模块化知识分享 未经允许，禁止转载 1.1 定义 1.1.1 模块化定义 Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.（摘自wiki百科） 模块化编程是一种软件设计技术，它强调将程序的功能分离为独立的、可互换的模块，使每个模块都包含执行所需功能的一个方面所必需的一切。","headline":"Android模块化知识分享","url":"https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/","@type":"BlogPosting","dateModified":"2021-08-08T15:09:42+08:00","datePublished":"2021-08-08T15:09:42+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/"},"@context":"https://schema.org"}</script><title>Android模块化知识分享 | Sulv's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sulv's Blog"><meta name="application-name" content="Sulv's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sulv's Blog</a></div><div class="site-subtitle font-italic">Coding Everyday!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/sulv9" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['3487260343','qq.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Android模块化知识分享</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Android模块化知识分享</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sulv </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2021-08-08, 15:09 +0800" >08-08<i class="unloaded">2021-08-08T15:09:42+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6079 字">33 分钟 阅读</span></div></div><div class="post-content"><h1 id="1-android模块化知识分享">1 Android模块化知识分享</h1><blockquote><p>未经允许，禁止转载</p><h2 id="11-定义">1.1 定义</h2><h3 id="111-模块化定义">1.1.1 模块化定义</h3><p><strong>Modular programming</strong> is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable <strong>modules</strong>, such that each contains everything necessary to execute only one aspect of the desired functionality.（摘自wiki百科）</p><p>模块化编程是一种软件设计技术，它强调将程序的功能分离为独立的、可互换的模块，使每个模块都包含执行所需功能的一个方面所必需的一切。</p></blockquote><p>大致意思就是，模块化将一个程序按照<strong>不同的功能</strong>拆分为<strong>相互独立</strong>的模块，每个模块只负责自己业务的开发，最后再将这些模块集成到<strong>主模块(Application Module)</strong> 中，通过路由实现不同模块间的跳转、通信和解耦。</p><h3 id="112-组件化开发定义">1.1.2 组件化开发定义</h3><blockquote><p><strong>Component-based software engineering (CBSE)</strong> , also called <strong>components-based development (CBD)</strong> , is a branch of software engineering that emphasizes the separation of concerns with respect to the wide-ranging functionality available throughout a given software system.（摘自wiki百科）</p><p>基于组件的软件工程（CBSE），也称为基于组件的开发（CBD），是软件工程的一个分支，它强调在给定的软件系统中，对于通用功能进行分离的思想。</p></blockquote><p>事实上，模块化与组件化之间没有明显的界限，组件化就是对不同模块的进一步细分，将一些模块的<strong>通用功能</strong>剥离出来形成一个组件，进一步提高程序的复用性。</p><h2 id="12-模块化与组件化的区别">1.2 模块化与组件化的区别</h2><ul><li>模块化是<strong>业务导向</strong>，主要针对业务逻辑层的拆分<li>组件化是<strong>功能导向</strong>，主要针对项目功能的拆分和重用</ul><h2 id="13-模块化组件化的优势">1.3 模块化/组件化的优势</h2><ul><li>单独编译，独立运行，减少项目编译运行时间<li>项目结构清晰，便于维护，提高团队开发效率<li>业务功能分离，实现高内聚，低耦合</ul><h2 id="14-项目架构的演变">1.4 项目架构的演变</h2><p>这里以我最近练手的项目为例进行说明</p><h3 id="141-无架构阶段">1.4.1 无架构阶段</h3><div align="center"> <img data-proofer-ignore data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60cd6cc1452d4e2aafebfccef180b6b9~tplv-k3u1fbpfcp-watermark.image" width="65%;" /></div><p>如果项目的所有功能都堆叠到一个模块中，代码间的耦合度就会大大提高，而且每当我们修改完一个功能的代码后就需要运行整个项目，等待时间长。</p><h3 id="142-模块化阶段">1.4.2 模块化阶段</h3><div align="center"> <img data-proofer-ignore data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09753613bbb046ee83b5684fd6445556~tplv-k3u1fbpfcp-watermark.image" width="65%;" /></div><p>按照业务模块进行拆分每个业务都是一个<strong>module</strong>，降低耦合度且能实现单独编译运行。</p><h3 id="143-业务层分离">1.4.3 业务层分离</h3><div align="center"> <img data-proofer-ignore data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c7af184fee4b4eb5c03006edcc668b~tplv-k3u1fbpfcp-watermark.image" width="80%;" /></div><p>将业务层模块中通用的方法提取出来形成<strong>基础层组件lib_base</strong>，提高功能的复用性，进一步解耦。这里我们分别使用<code class="language-plaintext highlighter-rouge">module_</code>和<code class="language-plaintext highlighter-rouge">lib_</code>前缀来区分业务组件和功能组件。</p><h3 id="144-基础层分离">1.4.4 基础层分离</h3><div align="center"> <img data-proofer-ignore data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b23d3033e68e495b96835e3e6c23777f~tplv-k3u1fbpfcp-watermark.image" width="80%;" /></div><p>如果一些自定义view，布局文件或者资源文件等会被多个模块使用，那么应该将它们从中剥离出来。但是如果将它们放到module_base中会破坏基础层的通用性，所以需要一个<strong>公共层module_common</strong>来专门提供上层业务模块的公共资源，同时也保证了<strong>基础层代码的通用性</strong>，不管放到哪个项目里面都可以正常运行。</p><h2 id="15-模块化组件化实战从问题出发">1.5 模块化/组件化实战——从问题出发</h2><h3 id="151-如何实现模块组件的单独调试">1.5.1 如何实现模块/组件的单独调试？</h3><h4 id="1511-实现效果">1.5.1.1 实现效果</h4><p>app主模块和文章模块分别编译运行后的结果如图所示：</p><div align="center"> <img data-proofer-ignore data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517576062fc14301a4a47b94cdb5fcf5~tplv-k3u1fbpfcp-watermark.image" width="40%;" /></div><p>其实要实现单独编译运行很简单，一共只需要<strong>两步</strong>。</p><h4 id="1512-配置不同的插件">1.5.1.2 配置不同的插件</h4><p>在没有模块化项目前，我们通常只有一个app主模块，在app模块的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件中通常第一行都会是下面这行代码：</p><blockquote><p>apply plugin: ‘com.android.application’</p></blockquote><p>这行代码的意思是指，在app模块中使用Android Gradle为我们提供的<strong>Application插件</strong>，其中<code class="language-plaintext highlighter-rouge">'com.android.application'</code>是该插件的id。Android Gradle一共为开发者提供了三种不同的插件，来帮助我们在开发过程中通过配置不同的插件来配置不同的工程：</p><ul><li>App插件：com.android.application<li>Library插件：com.android.library<li>Test插件：com.android.test</ul><p>其中使用了App插件的模块<strong>可以被独立运行</strong>，通常被用在可独立调试的业务模块中，如<code class="language-plaintext highlighter-rouge">module_article</code>, <code class="language-plaintext highlighter-rouge">module_user</code>等；使用了Library插件的模块<strong>不可独立运行</strong>，一般用在项目依赖的组件中，如<code class="language-plaintext highlighter-rouge">lib_common</code>, <code class="language-plaintext highlighter-rouge">lib_base</code>。</p><p>那么通过上面的知识，其实我们就已经有了独立调试模块的大概思路了，只是这个思路还需要一些完善。</p><p>首先我们需要注意的是，在组件化开发过程中，各个业务组件既可以<strong>单独调试</strong>又可以<strong>被其他模块依赖</strong>，这就需要我们提供<strong>一个变量<code class="language-plaintext highlighter-rouge">isSingleModuleDebug</code>来判断</strong>当前要运行的程序是否为模块的单独调试状态，如果为true，则各个组件可以被单独编译运行，反之则不行。有了思路，接下来我们就直接将其转换为代码吧。</p><p>首先在根目录下的<code class="language-plaintext highlighter-rouge">gradle.properties</code>文件中添加一个变量<code class="language-plaintext highlighter-rouge">isSingleModuleDebug</code>：</p><p>(Tips：<code class="language-plaintext highlighter-rouge">gradle.properties</code>文件中的内容可以被全局使用)</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="err">#</span> <span class="err">模块是否独立运行</span>
<span class="n">isSingleModuleDebug</span><span class="o">=</span><span class="kc">true</span>
</pre></table></code></div></div><p>然后打开所有需要单独调试模块的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件（例如<code class="language-plaintext highlighter-rouge">module_article</code>），在最上面添加以下判断代码并删除之前的<code class="language-plaintext highlighter-rouge">apply plugin: 'com.android.application'</code>：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">isSingleModuleDebug</span><span class="o">.</span><span class="na">toBoolean</span><span class="o">()){</span>
    <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.application'</span>
<span class="o">}</span><span class="k">else</span><span class="o">{</span>
    <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.library'</span>
<span class="o">}</span>
</pre></table></code></div></div><p>如果需要单独调试，则使用App插件，否则就使用Library插件（其实到每个模块中去挨个添加有些麻烦，后面会有一些优化的内容）。</p><p>另外，不要忘了删除<strong>除了主模块以外</strong>其他模块<code class="language-plaintext highlighter-rouge">build.gradle</code>文件中的<code class="language-plaintext highlighter-rouge">applicationId</code>，<strong>在集成调试时项目只允许出现一个<code class="language-plaintext highlighter-rouge">applicationId</code></strong>。</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">android</span> <span class="o">{</span>
    <span class="n">defaultConfig</span> <span class="o">{</span>
        <span class="c1">// 删除掉这一行</span>
        <span class="n">applicationId</span> <span class="s2">"com.aefottt.module_article"</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="1513-配置androidmanifest文件">1.5.1.3 配置AndroidManifest文件</h4><p>在新建一个模块后您会发现，在该模块的<code class="language-plaintext highlighter-rouge">manifests/AndroidManifest.xml</code>文件中存在以下代码，代表着在启动app时会以ArticleActivity文件为启动页：</p><div class="language-xml highlighter-rouge"><div class="code-header"> <span text-data=" XML "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">".ArticleActivity"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;intent-filter&gt;</span>
        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.MAIN"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.LAUNCHER"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/intent-filter&gt;</span>
<span class="nt">&lt;/activity&gt;</span>
</pre></table></code></div></div><p>当然，如果是单独运行该模块这段代码不会有啥问题，但是当各模块<strong>集成调试</strong>的时候呢？每个模块都有一个启动页，那app在启动时该先启动哪个界面？</p><p>针对这个问题，我们需要配置两个<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件，一个用于单独调试，一个用于集成调试，然后再在<code class="language-plaintext highlighter-rouge">build.gradle</code>文件中通过<code class="language-plaintext highlighter-rouge">isSingleModuleDebug</code>变量来判断并加载相应的<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件。</p><p>首先，我们切换至AndroidStudio的Project目录：</p><div align="center"> <img data-proofer-ignore data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e37611bd1a74484bc6f6e094c260ddd~tplv-k3u1fbpfcp-watermark.image" width="30%;" /></div><p>在<code class="language-plaintext highlighter-rouge">module_article</code>模块的<code class="language-plaintext highlighter-rouge">src/main</code>文件夹下新建<code class="language-plaintext highlighter-rouge">module</code>文件夹，在<code class="language-plaintext highlighter-rouge">module</code>文件夹下新建<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件。在模块单独调试运行时就会加载<code class="language-plaintext highlighter-rouge">module</code>文件夹下的<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件：</p><div align="center"> <img data-proofer-ignore data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b548a6aa9714c549a6e9cb20f94f484~tplv-k3u1fbpfcp-watermark.image" width="40%;" /></div><p>然后将<code class="language-plaintext highlighter-rouge">main/AndroidManifest.xml</code>文件中的代码内容全部<strong>搬运</strong>到<code class="language-plaintext highlighter-rouge">module/AndroidManifest.xml</code>文件中，在<code class="language-plaintext highlighter-rouge">main/AndroidManifest.xml</code>文件中只保留以下代码：</p><div class="language-xml highlighter-rouge"><div class="code-header"> <span text-data=" XML "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
    <span class="na">package=</span><span class="s">"com.aefottt.module_article"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;application</span> <span class="na">android:theme=</span><span class="s">"@style/AppTheme"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">".ArticleActivity"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/application&gt;</span>

<span class="nt">&lt;/manifest&gt;</span>
</pre></table></code></div></div><p>另外，您还需要注意的一点是，<strong>在集成调试的时候所有模块中Application的主题必须一致</strong>，否则在集中调试的时候会报错。由于所有模块都会引入<code class="language-plaintext highlighter-rouge">lib_common</code>库，我先在<code class="language-plaintext highlighter-rouge">lib_common</code>模块下的<code class="language-plaintext highlighter-rouge">values</code>文件中定义了一个通用的style: <code class="language-plaintext highlighter-rouge">AppTheme</code>，然后在所有模块的<code class="language-plaintext highlighter-rouge">main/AndroidManifest.xml</code>文件中设置application统一为该主题。当然您也可以使用其他模块的主题，只需要保证统一即可。</p><p>处理完<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件的内容后我们就可以开始配置module_article下的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件了：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">android</span><span class="o">{</span>
    <span class="k">sourceSets</span><span class="o">{</span>
        <span class="n">main</span><span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isSingleModuleDebug</span><span class="o">.</span><span class="na">toBoolean</span><span class="o">()){</span>
                <span class="n">manifest</span><span class="o">.</span><span class="na">srcFile</span> <span class="s1">'src/main/module/AndroidManifest.xml'</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">manifest</span><span class="o">.</span><span class="na">srcFile</span> <span class="s1">'src/main/AndroidManifest.xml'</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>代码的意思简单明了，如果是单独调试就加载module文件夹中的AndroidManifest文件，否则加载main下面的AndroidManifest文件，避免了集中调试时启动页的冲突问题。</p><p>接下来您就可以选择module_article模块，然后点击运行了。</p><div align="center"> <img data-proofer-ignore data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc92b540bf78496393f45f6b4e86eaa1~tplv-k3u1fbpfcp-watermark.image" width="60%;" /></div><h4 id="1514-配置文件优化-进一步解耦">1.5.1.4 配置文件优化 进一步解耦</h4><p>在上面apply插件的时候已经提到过，如果一个模块一个模块的去添加判断会有些麻烦，这些都是模板代码，完全可以提取出来，这是第一个问题。第二个问题就是依赖库版本太乱，需要进行统一管理。针对这两个问题，我们需要在项目根目录下新建两个gradle文件：<strong>config.gradle和version.gradle</strong>，一个是所有模块<code class="language-plaintext highlighter-rouge">build.gradle</code>文件的统一模板，另一个是对项目构建、依赖等版本号的统一管理。</p><p>首先我们可以先观察一下所有模块通用的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件是如何构成的。一共有三个作用域：plugin，android和dependencies。为了简单起见，我们直接全选任意模块的<code class="language-plaintext highlighter-rouge">build.gradle</code>内容，粘贴到<code class="language-plaintext highlighter-rouge">config.gradle</code>文件中去，将原本通过<code class="language-plaintext highlighter-rouge">isSingleModuleDebug</code>来判断并配置插件的代码换成下面的几行：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">isSingleModuleDebug</span><span class="o">.</span><span class="na">toBoolean</span><span class="o">()){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">project</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s2">"lib_.+"</span><span class="o">))</span>
        <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.library'</span>
    <span class="k">else</span>
        <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.application'</span>
<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">project</span><span class="o">.</span><span class="na">name</span> <span class="o">!=</span> <span class="s2">"app"</span><span class="o">)</span>
        <span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.library'</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在单独调试时如果模块名以<code class="language-plaintext highlighter-rouge">lib_</code>开头，则配置<code class="language-plaintext highlighter-rouge">Library插件</code>，否则配置<code class="language-plaintext highlighter-rouge">App插件</code>。在集成调试时，除了<code class="language-plaintext highlighter-rouge">app主模块</code>，其他模块统一配置<code class="language-plaintext highlighter-rouge">Library插件</code>。</p><p>这里我们统一将<strong>不需要单独调试的模块（即功能组件）</strong> 前缀改为<strong>lib_</strong> ，这是因为在单独调试时功能组件不需要进行调试，而且一般在功能组件中也不存在Activity，所以功能组件在允许时需要一直使用<code class="language-plaintext highlighter-rouge">Library插件</code>，如果这里不加判断的话，在单独调试的时候功能组件会出现applicactionId的报错问题。</p><p>接下来，我们对<code class="language-plaintext highlighter-rouge">build.gradle</code>中对<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件的内容进行提取，然后放到<code class="language-plaintext highlighter-rouge">config.gradle</code>文件中去：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">android</span><span class="o">{</span>
    <span class="k">sourceSets</span><span class="o">{</span>
        <span class="n">main</span><span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">project</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s2">"lib_.+"</span><span class="o">)){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isSingleModuleDebug</span><span class="o">.</span><span class="na">toBoolean</span><span class="o">()){</span>
                    <span class="n">manifest</span><span class="o">.</span><span class="na">srcFile</span> <span class="s1">'src/main/module/AndroidManifest.xml'</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="n">manifest</span><span class="o">.</span><span class="na">srcFile</span> <span class="s1">'src/main/AndroidManifest.xml'</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>如果模块的名字不以<code class="language-plaintext highlighter-rouge">lib_</code>开头，则在单独调试和集中调试时分别使用不同的<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件。</p><p>这样之后，我们就可以把<strong>除了主模块以外所有模块</strong>的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件内容全部删除，取而代之一行代码：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">apply</span> <span class="nl">from:</span> <span class="s1">'../config.gradle'</span>
</pre></table></code></div></div><p>由于在集成调试的时候需要有<code class="language-plaintext highlighter-rouge">App插件</code>和<code class="language-plaintext highlighter-rouge">applicationId</code>，所以在主app模块的<code class="language-plaintext highlighter-rouge">build.gradle</code>文件中我们还需要几行内容：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.application'</span>
<span class="n">apply</span> <span class="nl">from:</span> <span class="s1">'../config.gradle'</span>

<span class="n">android</span> <span class="o">{</span>
    <span class="n">defaultConfig</span> <span class="o">{</span>
        <span class="n">applicationId</span> <span class="s2">"com.aefottt.gankio"</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>第一个问题顺利解决，接下来我们看第二个问题，打开version.gradle文件，在这里对版本号进行统一管理。首先看一下项目版本和构建版本号的集中管理：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/** 版本号管理 **/</span>
<span class="n">ext</span><span class="o">.</span><span class="na">version_code</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ext</span><span class="o">.</span><span class="na">version_name</span> <span class="o">=</span> <span class="s2">"1.0"</span>
<span class="cm">/** 构建版本管理 **/</span>
<span class="kt">def</span> <span class="n">build_versions</span> <span class="o">=</span> <span class="o">[:]</span>
<span class="n">build_versions</span><span class="o">.</span><span class="na">compile_sdk</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">build_versions</span><span class="o">.</span><span class="na">build_tools</span> <span class="o">=</span> <span class="s2">"30.0.3"</span>
<span class="n">build_versions</span><span class="o">.</span><span class="na">min_sdk</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">build_versions</span><span class="o">.</span><span class="na">target_sdk</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">ext</span><span class="o">.</span><span class="na">build_versions</span> <span class="o">=</span> <span class="n">build_versions</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ext</code>是指在gradle中创建扩展插件，使得该属性能在其他gradle中被调用。</p><p>然后这里的<code class="language-plaintext highlighter-rouge">buile_versions</code>其实是一个HashMap，当然，即使不知道这个，之后的代码相信您也能很好的理解，为buile_versions添加相应的key-value键值对，最后将其添加到扩展插件中去。</p><p>然后为了能在其他gradle中使用<code class="language-plaintext highlighter-rouge">version.gradle</code>中的扩展插件，我们还需要打开项目<strong>根目录</strong>下的<code class="language-plaintext highlighter-rouge">buile.gradle</code>文件，在<code class="language-plaintext highlighter-rouge">buildscript{}</code>作用域中添加下面这行代码，表示全局可使用version.gradle中的插件：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">apply</span> <span class="nl">from:</span> <span class="s2">"version.gradle"</span>
</pre></table></code></div></div><p>接下来我们就可以替换<code class="language-plaintext highlighter-rouge">config.gradle</code>文件中关于版本号的内容了：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">android</span> <span class="o">{</span>
    <span class="n">compileSdkVersion</span> <span class="n">build_versions</span><span class="o">.</span><span class="na">compile_sdk</span>
    <span class="n">buildToolsVersion</span> <span class="n">build_versions</span><span class="o">.</span><span class="na">build_tools</span>

    <span class="n">defaultConfig</span> <span class="o">{</span>
        <span class="n">minSdkVersion</span> <span class="n">build_versions</span><span class="o">.</span><span class="na">min_sdk</span>
        <span class="n">targetSdkVersion</span> <span class="n">build_versions</span><span class="o">.</span><span class="na">target_sdk</span>
        <span class="n">versionCode</span> <span class="n">version_code</span>
        <span class="n">versionName</span> <span class="n">version_name</span>

        <span class="n">testInstrumentationRunner</span> <span class="s2">"androidx.test.runner.AndroidJUnitRunner"</span>
    <span class="o">}</span>
    <span class="o">......</span>
<span class="o">}</span>
</pre></table></code></div></div><p>至此对于两个问题的优化已经基本结束，事实上，您还可以对依赖库进行进一步的优化，例如将<code class="language-plaintext highlighter-rouge">config.gradle</code>中的版本库删除，取而代之将一些通用的依赖库添加到<code class="language-plaintext highlighter-rouge">lib_common</code>库中，然后在<code class="language-plaintext highlighter-rouge">config.gradle</code>中添加对<code class="language-plaintext highlighter-rouge">lib_common</code>的依赖。另外，您还可以将依赖库的版本号都放到<code class="language-plaintext highlighter-rouge">version.gradle</code>文件中，然后在使用<strong>implementation/api</strong>导入依赖，关于这部分代码您可以前往该项目的github地址（文章末尾处）查看。关于implementation和api的区别我在这里还需要提一下：</p><ul><li>implementation：使用该指令的依赖将隐藏在模块内部，而不对外公开，可以加快编译速度。<li>api：等同于compile，完全公开依赖，使得依赖可以被依赖该模块的模块使用。</ul><p>这里举个例子来帮助您更好的理解，假如在<code class="language-plaintext highlighter-rouge">lib_common</code>基础模块中导入了retrofit依赖，然后在<code class="language-plaintext highlighter-rouge">module_article</code>模块的<code class="language-plaintext highlighter-rouge">build.gradle</code>依赖中添加对<code class="language-plaintext highlighter-rouge">lib_common</code>的依赖，如果<code class="language-plaintext highlighter-rouge">lib_common</code>是使用api导入的retrofit依赖，就可以在<code class="language-plaintext highlighter-rouge">module_article</code>模块中使用Retrofit库，但如果是使用Implementation导入的，<code class="language-plaintext highlighter-rouge">module_article</code>就无法使用Retrofit库了。所以一般我们在<code class="language-plaintext highlighter-rouge">lib_common</code>中都使用api来导入依赖。</p><h3 id="152-如何实现模块组件间的通信">1.5.2 如何实现模块/组件间的通信？</h3><p>（这一节内容主要参考任玉刚前辈的文章，文章链接会在结尾指出。）</p><h4 id="1521-模块组件间界面跳转">1.5.2.1 模块/组件间界面跳转</h4><p>首先来看一下这样的业务场景：在启动APP后进入<code class="language-plaintext highlighter-rouge">启动页SplashActivity</code>，1秒后跳转，跳转时需要判断用户是否已登录，如果未登录则跳转到登录界面，反之跳转到主界面并加载用户信息。</p><div align="center"> <img data-proofer-ignore data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3403e4888e9c49f19549527b6ca04366~tplv-k3u1fbpfcp-watermark.image" width="58%;" /></div><p>其中主界面和启动页在app主模块中，登录界面在module_user中，那么对于不同模块间的跳转在这里我们将使用<strong>ARouter</strong>来实现。</p><blockquote><p>ARouter是一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦。</p></blockquote><p>ARouter可以帮助我们在不依赖彼此模块的前提下，实现不同模块间界面的跳转。使用ARouter一共分为三个步骤：<strong>配置，初始化，添加路径</strong>。</p><h5 id="一配置">一、配置</h5><p>配置一共需要注意三个点：</p><ol><li><p>所有模块都需要引入arouter-api依赖，这里我们就在module_base(基础组件)的<code class="language-plaintext highlighter-rouge">build.gradle</code>中添加依赖：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">api</span> <span class="n">deps</span><span class="o">.</span><span class="na">arouter</span><span class="o">.</span><span class="na">api</span>
</pre></table></code></div></div><p>这里的<code class="language-plaintext highlighter-rouge">deps.arouter.api</code>是我在<code class="language-plaintext highlighter-rouge">version.gradle</code>中定义的统一管理依赖版本的扩展插件中的内容，您也可以像下面这样写：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">api</span> <span class="s2">"com.alibaba:arouter-api:1.5.0"</span>
</pre></table></code></div></div><li><p>在<strong>所有需要用到ARouter的模块中</strong>添加arouter-compiler依赖，这里我为了方便就将其添加到了<code class="language-plaintext highlighter-rouge">config.gradle</code>（所有模块都会引入的gradle）中了：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">kapt</span> <span class="s2">"com.alibaba:arouter-compiler:1.2.2"</span>
</pre></table></code></div></div><li><p>同样在<strong>所有需要用到ARouter的模块中</strong>，在android{}领域中添加<code class="language-plaintext highlighter-rouge">javaCompileOptions</code>配置，这里我也把他们统一放在<code class="language-plaintext highlighter-rouge">config.gradle</code>中了：</p><div class="language-gradle highlighter-rouge"><div class="code-header"> <span text-data=" Gradle "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">android</span><span class="o">{</span>
    <span class="n">defaultConfig</span><span class="o">{</span>
        <span class="o">......</span>
        <span class="n">javaCompileOptions</span> <span class="o">{</span>
            <span class="n">annotationProcessorOptions</span> <span class="o">{</span>
                <span class="n">arguments</span> <span class="o">=</span> <span class="o">[</span> <span class="n">AROUTER_MODULE_NAME</span> <span class="o">:</span> <span class="n">project</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">]</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div></ol><h5 id="二初始化">二、初始化</h5><p>在app主模块中新建<code class="language-plaintext highlighter-rouge">GankApplication.kt</code>文件，继承自Application()，然后在<code class="language-plaintext highlighter-rouge">onCreate()</code>方法中添加如下几行代码：</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>    <span class="k">private</span> <span class="kd">val</span> <span class="py">isDebug</span> <span class="p">=</span> <span class="k">false</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">()</span>

        <span class="c1">// 初始化ARouter</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isDebug</span><span class="p">){</span>
            <span class="nc">ARouter</span><span class="p">.</span><span class="nf">openLog</span><span class="p">()</span>
            <span class="nc">ARouter</span><span class="p">.</span><span class="nf">openDebug</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nc">ARouter</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
        
    <span class="p">}</span>
</pre></table></code></div></div><p>最后别忘了在主模块的<code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code>文件中设置<code class="language-plaintext highlighter-rouge">android:name=".GankApplication"</code></p><h5 id="三添加路径">三、添加路径</h5><p>以上面的业务场景为例，需要跳转的界面有两个：<code class="language-plaintext highlighter-rouge">MainActivity</code>和<code class="language-plaintext highlighter-rouge">LoginActivity</code>，分别找到其对应的文件，在最外层class的上方添加路径：</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">@Route</span><span class="p">(</span><span class="n">path</span><span class="p">=</span><span class="s">"/main/main"</span><span class="p">)</span>
<span class="kd">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">......</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">@Route</span><span class="p">(</span><span class="n">path</span><span class="p">=</span><span class="s">"/user/login"</span><span class="p">)</span>
<span class="kd">class</span> <span class="nc">LoginActivity</span> <span class="p">:</span> <span class="nc">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">......</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里的路径名<strong>至少要有两级</strong>，且中间以<code class="language-plaintext highlighter-rouge">/</code>分隔开。</p><p><strong>这三个步骤做完之后</strong>您还需要在app主模块的<code class="language-plaintext highlighter-rouge">buile.gradle</code>中添加对所有用到ARouter模块的依赖（使用<code class="language-plaintext highlighter-rouge">implementation</code>添加依赖即可）。（Tips：这里<strong>只需要</strong>在主模块中添加依赖就可以了，假如要从<code class="language-plaintext highlighter-rouge">module_article</code>跳转到<code class="language-plaintext highlighter-rouge">module_user</code>，则二者之间<strong>并不需要添加依赖</strong>。）</p><p>然后我们就可以在<code class="language-plaintext highlighter-rouge">SplashActivity.kt</code>中编写相关的跳转逻辑了，这里为了方便我直接使用<code class="language-plaintext highlighter-rouge">SharedPreferences</code>来保存是否已登录的属性：</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>    <span class="kd">val</span> <span class="py">isLogin</span> <span class="p">=</span> <span class="nf">getSharedPreferences</span><span class="p">(</span><span class="s">"is_login"</span><span class="p">,</span> <span class="nc">MODE_PRIVATE</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">getBoolean</span><span class="p">(</span><span class="s">"isLogin"</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isLogin</span><span class="p">){</span>
        <span class="c1">// 跳转到主界面</span>
        <span class="nc">ARouter</span><span class="p">.</span><span class="nf">getInstance</span><span class="p">().</span><span class="nf">build</span><span class="p">(</span><span class="s">"/main/main"</span><span class="p">).</span><span class="nf">navigation</span><span class="p">()</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="c1">// 跳转到登录界面</span>
        <span class="nc">ARouter</span><span class="p">.</span><span class="nf">getInstance</span><span class="p">().</span><span class="nf">build</span><span class="p">(</span><span class="s">"/user/login"</span><span class="p">).</span><span class="nf">navigation</span><span class="p">()</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>当然您也可以通过<code class="language-plaintext highlighter-rouge">.withXxx()</code>在跳转时携带参数，更多诸如添加过滤拦截器的用法可以参考<a href="https://github.com/alibaba/ARouter/blob/master/README_CN.md">ARouter官网</a>。如果您在使用ARouter的过程中遇见无法跳转的问题，可以<code class="language-plaintext highlighter-rouge">GankApplication.kt</code>中的<code class="language-plaintext highlighter-rouge">isDebug</code>属性设置为<code class="language-plaintext highlighter-rouge">true</code>。</p><p>接着就是在<code class="language-plaintext highlighter-rouge">LoginActivity.kt</code>中添加登录按钮，点击后修改<code class="language-plaintext highlighter-rouge">SharedPreferences</code>的属性值并跳转到<code class="language-plaintext highlighter-rouge">MainActivity</code>，基本逻辑没什么问题，这里就不赘述，可自行查看github源码。</p><h4 id="1522-模块组件间数据传递">1.5.2.2 模块/组件间数据传递</h4><p>继续上面的业务逻辑，在<code class="language-plaintext highlighter-rouge">MainActivity</code>中我们需要展示用户信息和文章简介等内容，这里就以如何在<code class="language-plaintext highlighter-rouge">MainActivity</code>中获取<code class="language-plaintext highlighter-rouge">module_user</code>里<code class="language-plaintext highlighter-rouge">UserActivity</code>的用户信息为例，来说明组件间的数据传递内容。</p><p>首先，如果要通过<code class="language-plaintext highlighter-rouge">MainActivity</code>获取到<code class="language-plaintext highlighter-rouge">UserActivity</code>中的用户信息，我们需要在<code class="language-plaintext highlighter-rouge">module_user</code>中提供一个供其他模块调用的方法，例如在<code class="language-plaintext highlighter-rouge">module_user</code>中新建一个类文件<code class="language-plaintext highlighter-rouge">UserService.kt</code>，在这里提供获取用户信息的方法：</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">fun</span> <span class="nf">getUserId</span><span class="p">():</span> <span class="nc">String</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"这是用户信息"</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在app主模块中添加对<code class="language-plaintext highlighter-rouge">module_user</code>的依赖，就可以直接实例化<code class="language-plaintext highlighter-rouge">UserService</code>对象并调用它对应的方法来获取用户信息了。但是这里存在两个问题：</p><ol><li><strong>模块间耦合度太高</strong>：如果moduleA需要获取moduleB中的数据，就需要在<code class="language-plaintext highlighter-rouge">build.gradle</code>中添加对moduleB的依赖，才能使用moduleB中类的方法。<li><strong>会产生循环依赖问题</strong>：如果moduleA需要获取到moduleB中的数据，moduleB也需要获取到moduleA中的数据，那么二者就需要相互添加对彼此的依赖，这是不允许的。</ol><p>其实上述的两个问题的本质还是要尽量减少模块间的耦合度。那么首先这里就有一个解决方案：将两个模块间通信的接口<strong>下沉到底层组件lib_common中</strong>，通过<code class="language-plaintext highlighter-rouge">lib_common</code>统一管理模块间的通信，具体的下沉逻辑请看下图：</p><div align="center"> <img data-proofer-ignore data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0f1a70b29e34564bb04e76e4169aba5~tplv-k3u1fbpfcp-watermark.image" /></div><p>在这个图中<code class="language-plaintext highlighter-rouge">lib_common</code>起着<strong>桥梁</strong>的作用，对<strong>需要传递数据的模块</strong>（如<code class="language-plaintext highlighter-rouge">module_user</code>和<code class="language-plaintext highlighter-rouge">module_article</code>）提供相应的接口和空接口实现（实现空接口是为了防止在对应的模块未实现该接口时不会产生运行错误，而是返回默认的数据）。在<code class="language-plaintext highlighter-rouge">module_user</code>和<code class="language-plaintext highlighter-rouge">module_article</code>中分别实现对应的接口，然后在需要获取数据的模块<code class="language-plaintext highlighter-rouge">module_main</code>中调用<code class="language-plaintext highlighter-rouge">ServiceFactory</code>里相应的方法，来获得数据。具体各类的代码实现如下：</p><p><strong>lib_common\ServiceFactory.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">object</span> <span class="nc">ServiceFactory</span> <span class="p">{</span>
    <span class="c1">// 获取用户信息的服务</span>
    <span class="kd">var</span> <span class="py">user_service</span><span class="p">:</span> <span class="nc">IUserService</span> <span class="p">=</span> <span class="nc">EmptyUserService</span><span class="p">()</span>
    <span class="c1">// 获取文章信息的服务</span>
    <span class="kd">var</span> <span class="py">article_service</span><span class="p">:</span> <span class="nc">IArticleService</span> <span class="p">=</span> <span class="nc">EmptyArticleService</span><span class="p">()</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>lib_common\IUserService.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">interface</span> <span class="nc">IUserService</span> <span class="p">{</span>
    
    <span class="k">fun</span> <span class="nf">isLogin</span><span class="p">():</span> <span class="nc">Boolean</span>
    
    <span class="k">fun</span> <span class="nf">getUserId</span><span class="p">():</span> <span class="nc">String</span><span class="p">?</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>lib_common\EmptyUserService.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">EmptyUserService</span> <span class="p">:</span> <span class="nc">IUserService</span> <span class="p">{</span>
   
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">isLogin</span><span class="p">()</span> <span class="p">=</span> <span class="k">false</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUserId</span><span class="p">():</span> <span class="nc">String</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>module_user\service\UserService.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">UserService</span> <span class="p">:</span> <span class="nc">IUserService</span> <span class="p">{</span>
    <span class="c1">// 是否已登录</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">isLogin</span><span class="p">():</span> <span class="nc">Boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nc">LoginActivity</span><span class="p">.</span><span class="n">isLogin</span>
    <span class="p">}</span>
    <span class="c1">// 获取用户信息</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getUserId</span><span class="p">():</span> <span class="nc">String</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"这是用户信息"</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后我们就可以直接在<code class="language-plaintext highlighter-rouge">MainActivity.kt</code>中调用<code class="language-plaintext highlighter-rouge">ServiceFactory</code>相应的方法来获取到用户信息了：</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">ServiceFactory</span><span class="p">.</span><span class="n">user_service</span><span class="p">.</span><span class="nf">getUserId</span><span class="p">()</span>
</pre></table></code></div></div><p>当然，到这里我们获取到的数据还是空实现类中默认返回的数据，还需要在<strong>app初始化</strong>的时候依次创建类的实例。由于在集中调试的时候各模块的<code class="language-plaintext highlighter-rouge">Application</code>是<strong>无法初始化</strong>的，所以我们需要在主模块中通过<strong>反射</strong>依次获取各个模块的<code class="language-plaintext highlighter-rouge">Application</code>，并执行其中相应的初始化方法。</p><p>这里我们首先在<code class="language-plaintext highlighter-rouge">lib_common</code>模块中配置<em>所有需要进行初始化的模块</em>的信息，即<strong>包名</strong>：</p><p><strong>lib_common\AppConfig.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">AppConfig</span> <span class="p">{</span>
    
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="kd">val</span> <span class="py">moduleApps</span> <span class="p">=</span> <span class="nf">setOf</span><span class="p">(</span>
            <span class="s">"com.aefottt.module_user.LoginApp"</span><span class="p">,</span>
            <span class="s">"com.aefottt.module_article.ArticleApp"</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后新建Application的基类<code class="language-plaintext highlighter-rouge">BaseApp.kt</code>，所有模块的<code class="language-plaintext highlighter-rouge">Application文件</code>都需要继承自该<code class="language-plaintext highlighter-rouge">BaseApp类</code>：</p><p><strong>lib_common\BaseApp.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">abstract</span> <span class="kd">class</span> <span class="nc">BaseApp</span><span class="p">:</span> <span class="nc">Application</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">initModuleApp</span><span class="p">(</span><span class="n">application</span><span class="p">:</span> <span class="nc">Application</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">module_user</code>和<code class="language-plaintext highlighter-rouge">module_article</code>中分别新建各自的<code class="language-plaintext highlighter-rouge">Application</code>文件，在其中初始化接口的实现类：</p><p><strong>module_user\LoginApp.kt</strong></p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">LoginApp</span> <span class="p">:</span> <span class="nc">BaseApp</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">initModuleApp</span><span class="p">(</span><span class="n">application</span><span class="p">:</span> <span class="nc">Application</span><span class="p">)</span> <span class="p">{</span>
        <span class="nc">ServiceFactory</span><span class="p">.</span><span class="n">user_service</span> <span class="p">=</span> <span class="nc">UserService</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>最后</strong>，在app主模块的<code class="language-plaintext highlighter-rouge">GankApplication.kt</code>文件中通过反射依次获取类的实例，并调用其中的初始化方法：</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">GankApplication</span><span class="p">:</span> <span class="nc">BaseApp</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">()</span>

        <span class="nf">initModuleApp</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>

        <span class="o">......</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">initModuleApp</span><span class="p">(</span><span class="n">application</span><span class="p">:</span> <span class="nc">Application</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">appPath</span> <span class="k">in</span> <span class="nc">AppConfig</span><span class="p">.</span><span class="n">moduleApps</span><span class="p">){</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="kd">val</span> <span class="py">clazz</span> <span class="p">=</span> <span class="nc">Class</span><span class="p">.</span><span class="nf">forName</span><span class="p">(</span><span class="n">appPath</span><span class="p">)</span>
                <span class="kd">val</span> <span class="py">baseApp</span> <span class="p">=</span> <span class="n">clazz</span><span class="p">.</span><span class="nf">newInstance</span><span class="p">()</span> <span class="k">as</span> <span class="nc">BaseApp</span>
                <span class="n">baseApp</span><span class="p">.</span><span class="nf">initModuleApp</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
            <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="nc">Exception</span><span class="p">){</span>
                <span class="n">e</span><span class="p">.</span><span class="nf">printStackTrace</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><p>到这里通过下沉接口实现组件间的数据传递的实现就完成了。但是参考<em>美团Android组件化方案</em>，其中对于循环依赖的解决办法是<strong>把每个业务组件都拆分成了一个Export Module和Implement Module</strong>，其中<code class="language-plaintext highlighter-rouge">Export Module</code>复杂对外提供接口，<code class="language-plaintext highlighter-rouge">Implement Module</code>负责实现业务逻辑，不对外开发。这样的话如果<code class="language-plaintext highlighter-rouge">ModuleA</code>需要使用<code class="language-plaintext highlighter-rouge">ModuleB</code>的数据，就只需引入对<code class="language-plaintext highlighter-rouge">Module B的Export Module</code>的依赖即可，而不再需要添加对<code class="language-plaintext highlighter-rouge">ModuleB</code>的依赖了。<code class="language-plaintext highlighter-rouge">ModuleB</code>如果需要使用<code class="language-plaintext highlighter-rouge">ModuleA</code>的数据也同理，下面引入美团的一张图来说明：</p><div align="center"> <img data-proofer-ignore data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7469259ae9994a83bb2f02b7aa471498~tplv-k3u1fbpfcp-watermark.image" width="68%;" /></div><blockquote><p>题外话：</p><p>第一次在掘金发文章，之前一直都是在看，这次借着培训时需要讲课件的机会，把我准备的课件知识分享出来，当然我写的不是最好的，还有其他人写的比我要好，然后我准备的课件主题是模块化与热修复，这一篇就是我准备的模块化的内容，关于热修复我只准备了关于类加载机制源码分析的内容，实战手撸热修复框架的过程还是遇到了困难，网上相关的文章比较久远，和现在as版本有一些出入，例如Instant Run已经被移除了，取而代之的是Change，还有就是classes.dex文件始终找不到，等着以后有时间研究好了再发出来吧。</p><p>然后这篇文章中如果有描述不足或者不正确的地方，希望大家能及时指出，谢谢您的观看。</p></blockquote><p>Github链接: <a href="https://github.com/Aefottt007/GankIo">Aefottt007/GankIo (github.com)</a></p><p>参考文章：</p><p><a href="https://juejin.cn/post/6844903649102004231">Android 组件化最佳实践 (juejin.cn)</a></p><p><a href="https://www.jianshu.com/p/748bf621a9a0">Android组件化/模块化开发(一)</a></p><p><a href="https://blog.csdn.net/Next_Second/article/details/78428086">android gradle 3.0.0 中依赖指令implementation、api 的区别_杨小熊学习笔记-CSDN博客</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tech/'>Tech</a>, <a href='/categories/android/'>Android</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/modular/" class="post-tag no-text-decoration" >modular</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Android模块化知识分享 - Sulv's Blog&url=https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Android模块化知识分享 - Sulv's Blog&u=https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Android模块化知识分享 - Sulv's Blog&url=https://sulv9.github.io/posts/Android-Modular-Konwledge-Sharing/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2020-year-summary/">2020年度总结，初入大学的自己</a><li><a href="/posts/2021-year-summary/">2021年度总结，收获爱情的一年</a><li><a href="/posts/java-started-knowledge-introduction/">Java入门知识讲解</a><li><a href="/posts/ARTS-1/">ARTS-1</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/year-summary/">year-summary</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/arts/">ARTS</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/modular/">modular</a> <a class="post-tag" href="/tags/movies/">movies</a> <a class="post-tag" href="/tags/record/">record</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-started-knowledge-introduction/"><div class="card-body"> <span class="timeago small" >09-06<i class="unloaded">2021-09-06T22:12:25+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java入门知识讲解</h3><div class="text-muted small"><p> 前言：本次入门教程专为21级红岩移动Android开发部学员所写，希望能帮助你快速入门。 简单的Java程序分析 首先我们先来分析一下在课件安装IDEA的教程里你所抄写的最后一张图上的代码的含义： 1 2 3 4 5 public class Main { public static void main(String[] args){ System.out...</p></div></div></a></div><div class="card"> <a href="/posts/ARTS-1/"><div class="card-body"> <span class="timeago small" >09-08<i class="unloaded">2021-09-08T15:10:43+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>ARTS-1</h3><div class="text-muted small"><p> 前言：因为是第一次做ARTS，再加上刚开学要迎新，还有一些学业等等其他的一些事情，现在是2021年9月23日，距离新建这篇文章已经过去了十五天的时间，两周零一天，效率之低令人惊叹，划水之怠令人懊悔。但“悟已往之不谏，知来者之可追”，与其抱怨黑暗，不如提灯前行。现在是周四，周日还要补下周三的课，定个目标，这周结束前将Arouter的相关知识搞定（但博客可能要来不及写了）。 ...</p></div></div></a></div><div class="card"> <a href="/posts/git-guide-basics/"><div class="card-body"> <span class="timeago small" >09-18<i class="unloaded">2021-09-18T14:14:43+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Git指南-基础篇</h3><div class="text-muted small"><p> 为什么要用Git？ 方便多人远程协作开发 教学相长，在review别人代码的同时也能被别人发现自己代码里的问题，提升代码水平 可以让你放心大胆地开发，随时可以回退版本或者新建分支 Git常用指令指南 新建代码仓库 git init 初始化Git仓库 git clone [url] 克隆远程仓库代码到本地 Git con...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2020-year-summary/" class="btn btn-outline-primary" prompt="上一篇"><p>2020年度总结，初入大学的自己</p></a> <a href="/posts/java-started-knowledge-introduction/" class="btn btn-outline-primary" prompt="下一篇"><p>Java入门知识讲解</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://juejin.cn/user/2321803287986775">Sulv</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/year-summary/">year summary</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/arts/">ARTS</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/modular/">modular</a> <a class="post-tag" href="/tags/movies/">movies</a> <a class="post-tag" href="/tags/record/">record</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
